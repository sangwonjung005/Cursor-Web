#!/usr/bin/env node
/**
 * ÏóêÎÑàÏßÄ Ïù∏Ï¶ùÏÑú NFT ÏûêÎèô ÎØºÌåÖ ÏÑúÎ≤Ñ (Node.js + Express)
 * RE100, CBAM, ÌÉÑÏÜåÍ±∞ÎûòÏö© NFT ÏÉùÏÑ± Î∞è Í¥ÄÎ¶¨ API
 */

const express = require('express');
const { ethers } = require('ethers');
const axios = require('axios');
const FormData = require('form-data');
const fs = require('fs').promises;
const path = require('path');
const dotenv = require('dotenv');

// ÌôòÍ≤Ω Î≥ÄÏàò Î°úÎìú
dotenv.config();

class EnergyNFTMinter {
    constructor() {
        this.provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
        this.wallet = new ethers.Wallet(process.env.PRIVATE_KEY, this.provider);
        this.contractAddress = process.env.CONTRACT_ADDRESS;
        this.contract = null;
        this.initContract();
    }

    async initContract() {
        try {
            // ABI ÌååÏùº Î°úÎìú
            const abiPath = path.join(__dirname, '../artifacts/contracts/EnergyCertificateNFT.sol/EnergyCertificateNFT.json');
            const contractJson = JSON.parse(await fs.readFile(abiPath, 'utf8'));
            
            this.contract = new ethers.Contract(
                this.contractAddress,
                contractJson.abi,
                this.wallet
            );
            
            console.log('‚úÖ Ïä§ÎßàÌä∏Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞ ÏôÑÎ£å');
        } catch (error) {
            console.error('‚ùå Ïª®Ìä∏ÎûôÌä∏ Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
        }
    }

    /**
     * ÏóêÎÑàÏßÄ ÌÉÄÏûÖÎ≥Ñ Ïù¥ÎØ∏ÏßÄ URL Î∞òÌôò
     */
    getEnergyTypeImage(energyType) {
        const imageMapping = {
            'solar': 'ipfs://QmSolarPanelIcon/solar.png',
            'wind': 'ipfs://QmWindTurbineIcon/wind.png',
            'hydro': 'ipfs://QmHydroIcon/hydro.png',
            'biomass': 'ipfs://QmBiomassIcon/biomass.png'
        };
        return imageMapping[energyType] || 'ipfs://QmDefaultEnergyIcon/default.png';
    }

    /**
     * ÌÉÑÏÜå ÌöåÌîºÎüâ Í≥ÑÏÇ∞
     */
    calculateCarbonOffset(energyAmount, energyType) {
        const carbonFactors = {
            'solar': 0.466,
            'wind': 0.011,
            'hydro': 0.024,
            'biomass': 0.18
        };
        return energyAmount * (carbonFactors[energyType] || 0.4);
    }

    /**
     * NFT Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
     */
    generateMetadata(energyData) {
        const carbonOffset = this.calculateCarbonOffset(
            energyData.energyAmount, 
            energyData.energyType
        );

        return {
            name: `RE100 Ï†ÑÎ†• NFT #${energyData.tokenId || 'TBD'}`,
            description: `${energyData.energyAmount}MWh ${energyData.energyType} Ï†ÑÎ†• Í±∞Îûò Ïù∏Ï¶ùÏÑú`,
            image: this.getEnergyTypeImage(energyData.energyType),
            external_url: `https://energy-nft.com/token/${energyData.tokenId || ''}`,
            attributes: [
                {
                    trait_type: "Ï†ÑÎ†•Îüâ (MWh)",
                    value: energyData.energyAmount,
                    display_type: "number"
                },
                {
                    trait_type: "ÏóêÎÑàÏßÄ ÌÉÄÏûÖ",
                    value: energyData.energyType
                },
                {
                    trait_type: "Í±∞ÎûòÏùºÏãú",
                    value: energyData.timestamp || new Date().toISOString()
                },
                {
                    trait_type: "Í≥µÍ∏âÏûê",
                    value: energyData.supplier
                },
                {
                    trait_type: "ÏàòÏöîÏûê",
                    value: energyData.buyer
                },
                {
                    trait_type: "Î∞úÏ†ÑÏÜå ÏúÑÏπò",
                    value: energyData.location
                },
                {
                    trait_type: "ÌÉÑÏÜå ÌöåÌîºÎüâ (tCO‚ÇÇ)",
                    value: Math.round(carbonOffset * 1000) / 1000,
                    display_type: "number"
                },
                {
                    trait_type: "RE100 Ï†ÅÌï©ÏÑ±",
                    value: "Ïù∏Ï¶ùÎê®"
                },
                {
                    trait_type: "CBAM ÎåÄÏùë",
                    value: "Ï†ÅÌï©"
                }
            ],
            properties: {
                category: "Energy Certificate",
                subcategory: energyData.energyType.charAt(0).toUpperCase() + energyData.energyType.slice(1),
                is_renewable: true,
                certification_standard: "RE100",
                carbon_offset_tco2: carbonOffset,
                energy_amount_mwh: energyData.energyAmount
            }
        };
    }

    /**
     * IPFSÏóê Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎ°úÎìú (Pinata ÏÇ¨Ïö©)
     */
    async uploadToIPFS(metadata) {
        try {
            const formData = new FormData();
            const jsonBuffer = Buffer.from(JSON.stringify(metadata, null, 2));
            
            formData.append('file', jsonBuffer, {
                filename: `metadata_${Date.now()}.json`,
                contentType: 'application/json'
            });

            const response = await axios.post(
                'https://api.pinata.cloud/pinning/pinFileToIPFS',
                formData,
                {
                    headers: {
                        ...formData.getHeaders(),
                        'pinata_api_key': process.env.PINATA_API_KEY,
                        'pinata_secret_api_key': process.env.PINATA_SECRET_KEY
                    }
                }
            );

            const ipfsHash = response.data.IpfsHash;
            const ipfsUrl = `ipfs://${ipfsHash}`;
            
            console.log(`‚úÖ IPFS ÏóÖÎ°úÎìú ÏôÑÎ£å: ${ipfsUrl}`);
            return ipfsUrl;

        } catch (error) {
            console.error('‚ùå IPFS ÏóÖÎ°úÎìú Ïã§Ìå®:', error.message);
            throw error;
        }
    }

    /**
     * ÏóêÎÑàÏßÄ NFT ÎØºÌåÖ
     */
    async mintEnergyNFT(energyData) {
        try {
            console.log('üöÄ NFT ÎØºÌåÖ ÏãúÏûë...');

            // 1. Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
            const metadata = this.generateMetadata(energyData);
            console.log('üìÑ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± ÏôÑÎ£å');

            // 2. IPFS ÏóÖÎ°úÎìú
            const tokenURI = await this.uploadToIPFS(metadata);

            // 3. ÌÉÑÏÜå ÌöåÌîºÎüâ Í≥ÑÏÇ∞ (Ï†ïÏàòÎ°ú Î≥ÄÌôò)
            const carbonOffset = Math.floor(
                this.calculateCarbonOffset(energyData.energyAmount, energyData.energyType) * 1000
            );

            // 4. ÏóêÎÑàÏßÄÎüâÏùÑ kWhÎ°ú Î≥ÄÌôò
            const energyAmountKWh = Math.floor(energyData.energyAmount * 1000);

            // 5. Ïä§ÎßàÌä∏Ïª®Ìä∏ÎûôÌä∏ Ìï®Ïàò Ìò∏Ï∂ú
            const tx = await this.contract.mintEnergyNFT(
                energyData.buyer,           // recipient
                tokenURI,                   // tokenURI
                energyAmountKWh,           // energyAmount (kWh)
                energyData.supplier,        // supplier
                energyData.buyer,          // buyer
                energyData.energyType,     // energyType
                carbonOffset,              // carbonOffset
                energyData.location,       // location
                {
                    gasLimit: 500000,
                    gasPrice: ethers.parseUnits('10', 'gwei')
                }
            );

            console.log(`‚úÖ ÎØºÌåÖ Ìä∏ÎûúÏû≠ÏÖò Ï†ÑÏÜ°: ${tx.hash}`);

            // 6. Ìä∏ÎûúÏû≠ÏÖò ÌôïÏù∏ ÎåÄÍ∏∞
            const receipt = await tx.wait();
            
            if (receipt.status === 1) {
                console.log(`üéâ NFT ÎØºÌåÖ ÏÑ±Í≥µ! Gas ÏÇ¨Ïö©Îüâ: ${receipt.gasUsed}`);
                
                // Ïù¥Î≤§Ìä∏ÏóêÏÑú ÌÜ†ÌÅ∞ ID Ï∂îÏ∂ú
                const event = receipt.logs.find(log => {
                    try {
                        return this.contract.interface.parseLog(log).name === 'EnergyNFTMinted';
                    } catch {
                        return false;
                    }
                });

                let tokenId = null;
                if (event) {
                    const parsedEvent = this.contract.interface.parseLog(event);
                    tokenId = parsedEvent.args.tokenId.toString();
                }

                return {
                    success: true,
                    txHash: tx.hash,
                    tokenId: tokenId,
                    gasUsed: receipt.gasUsed.toString(),
                    tokenURI: tokenURI,
                    metadata: metadata
                };
            } else {
                throw new Error('Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå®');
            }

        } catch (error) {
            console.error('‚ùå NFT ÎØºÌåÖ Ïã§Ìå®:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Î∞∞Ïπò ÎØºÌåÖ
     */
    async batchMint(energyDataList) {
        const results = [];
        
        for (let i = 0; i < energyDataList.length; i++) {
            console.log(`üì¶ Î∞∞Ïπò ÎØºÌåÖ ÏßÑÌñâ Ï§ë... (${i + 1}/${energyDataList.length})`);
            
            const result = await this.mintEnergyNFT(energyDataList[i]);
            results.push({
                index: i,
                data: energyDataList[i],
                result: result
            });

            // API Î†àÏù¥Ìä∏ Î¶¨ÎØ∏Ìä∏ Î∞©ÏßÄ
            if (i < energyDataList.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }

        return results;
    }

    /**
     * ÌÜ†ÌÅ∞ Ï†ïÎ≥¥ Ï°∞Ìöå
     */
    async getTokenInfo(tokenId) {
        try {
            const energyData = await this.contract.getEnergyData(tokenId);
            const tokenURI = await this.contract.tokenURI(tokenId);
            const owner = await this.contract.ownerOf(tokenId);

            return {
                tokenId: tokenId,
                owner: owner,
                tokenURI: tokenURI,
                energyData: {
                    energyAmount: energyData.energyAmount.toString(),
                    timestamp: new Date(Number(energyData.timestamp) * 1000).toISOString(),
                    supplier: energyData.supplier,
                    buyer: energyData.buyer,
                    energyType: energyData.energyType,
                    carbonOffset: energyData.carbonOffset.toString(),
                    location: energyData.location,
                    isRetired: energyData.isRetired
                }
            };
        } catch (error) {
            throw new Error(`ÌÜ†ÌÅ∞ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: ${error.message}`);
        }
    }

    /**
     * Ï¥ù ÌÉÑÏÜå ÌöåÌîºÎüâ Ï°∞Ìöå
     */
    async getTotalCarbonOffset(ownerAddress) {
        try {
            const totalOffset = await this.contract.getTotalCarbonOffset(ownerAddress);
            return (Number(totalOffset) / 1000).toString(); // tCO2 Îã®ÏúÑÎ°ú Î≥ÄÌôò
        } catch (error) {
            throw new Error(`ÌÉÑÏÜå ÌöåÌîºÎüâ Ï°∞Ìöå Ïã§Ìå®: ${error.message}`);
        }
    }
}

// Express ÏÑúÎ≤Ñ ÏÑ§Ï†ï
const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static('public'));

// CORS ÎØ∏Îì§Ïõ®Ïñ¥
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
    next();
});

// NFT ÎØºÌÑ∞ Ïù∏Ïä§ÌÑ¥Ïä§
const minter = new EnergyNFTMinter();

// API ÏóîÎìúÌè¨Ïù∏Ìä∏
app.get('/', (req, res) => {
    res.json({
        message: 'üå± ÏóêÎÑàÏßÄ Ïù∏Ï¶ùÏÑú NFT ÎØºÌåÖ API',
        version: '1.0.0',
        endpoints: {
            mint: 'POST /api/mint',
            batchMint: 'POST /api/batch-mint',
            tokenInfo: 'GET /api/token/:tokenId',
            carbonOffset: 'GET /api/carbon-offset/:address'
        }
    });
});

// Îã®Ïùº NFT ÎØºÌåÖ
app.post('/api/mint', async (req, res) => {
    try {
        const energyData = req.body;
        
        // ÌïÑÏàò ÌïÑÎìú Í≤ÄÏ¶ù
        const requiredFields = ['energyAmount', 'energyType', 'supplier', 'buyer', 'location'];
        for (const field of requiredFields) {
            if (!energyData[field]) {
                return res.status(400).json({
                    success: false,
                    error: `ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ: ${field}`
                });
            }
        }

        const result = await minter.mintEnergyNFT(energyData);
        res.json(result);

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Î∞∞Ïπò ÎØºÌåÖ
app.post('/api/batch-mint', async (req, res) => {
    try {
        const { energyDataList } = req.body;
        
        if (!Array.isArray(energyDataList) || energyDataList.length === 0) {
            return res.status(400).json({
                success: false,
                error: 'energyDataListÎäî ÎπÑÏñ¥ÏûàÏßÄ ÏïäÏùÄ Î∞∞Ïó¥Ïù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.'
            });
        }

        const results = await minter.batchMint(energyDataList);
        res.json({
            success: true,
            results: results
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// ÌÜ†ÌÅ∞ Ï†ïÎ≥¥ Ï°∞Ìöå
app.get('/api/token/:tokenId', async (req, res) => {
    try {
        const tokenId = req.params.tokenId;
        const tokenInfo = await minter.getTokenInfo(tokenId);
        res.json({
            success: true,
            data: tokenInfo
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// ÌÉÑÏÜå ÌöåÌîºÎüâ Ï°∞Ìöå
app.get('/api/carbon-offset/:address', async (req, res) => {
    try {
        const address = req.params.address;
        const totalOffset = await minter.getTotalCarbonOffset(address);
        res.json({
            success: true,
            address: address,
            totalCarbonOffset: totalOffset,
            unit: 'tCO‚ÇÇ'
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// ÏÑúÎ≤Ñ ÏãúÏûë
app.listen(PORT, () => {
    console.log(`üöÄ ÏóêÎÑàÏßÄ NFT ÎØºÌåÖ ÏÑúÎ≤ÑÍ∞Ä http://localhost:${PORT}ÏóêÏÑú Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§.`);
    console.log(`üì° ÎÑ§Ìä∏ÏõåÌÅ¨: ${process.env.NETWORK || 'sepolia'}`);
    console.log(`üìç Ïª®Ìä∏ÎûôÌä∏: ${process.env.CONTRACT_ADDRESS}`);
});

module.exports = { EnergyNFTMinter, app };